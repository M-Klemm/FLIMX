function SmoothY=fastsmooth(Y,w,type,ends)% fastbsmooth(Y,w,type,ends) smooths vector Y with smooth %  of width w. Version 2.0, May 2008.% The argument "type" determines the smooth type:%   If type=1, rectangular (sliding-average or boxcar) %   If type=2, triangular (2 passes of sliding-average)%   If type=3, pseudo-Gaussian (3 passes of sliding-average)% The argument "ends" controls how the "ends" of the signal % (the first w/2 points and the last w/2 points) are handled.%   If ends=0, the ends are zero.  (In this mode the elapsed %     time is independent of the smooth width). The fastest.%   If ends=1, the ends are smoothed with progressively %     smaller smooths the closer to the end. (In this mode the  %     elapsed time increases with increasing smooth widths).% fastsmooth(Y,w,type) smooths with ends=0.% fastsmooth(Y,w) smooths with type=1 and ends=0.% Example:% fastsmooth([1 1 1 10 10 10 1 1 1 1],3)= [0 1 4 7 10 7 4 1 1 0]% fastsmooth([1 1 1 10 10 10 1 1 1 1],3,1,1)= [1 1 4 7 10 7 4 1 1 1]%  T. C. O'Haver, May, 2008.if nargin==2, ends=0; type=1; endif nargin==3, ends=0; endw = min(length(Y),w); %M.Klemm  switch type    case 1       SmoothY=sa(Y,w,ends);    case 2          SmoothY=sa(sa(Y,w,ends),w,ends);    case 3       SmoothY=sa(sa(sa(Y,w,ends),w,ends),w,ends);  end    function SmoothY=sa(Y,smoothwidth,ends)        w=round(smoothwidth);        %         SumPoints=sum(Y(1:w));        %         s=zeros(size(Y));        %         halfw=round(w/2);        L=length(Y);        %         for k=1:L-w,        %             s(k+halfw-1)=SumPoints;        %             SumPoints=SumPoints-Y(k);        %             SumPoints=SumPoints+Y(k+w);        %         end        %         s(k+halfw)=sum(Y(L-w+1:L));        %         SmoothY=s./w;%         if(max(Y(:)) * w < 32767) %intmax('int16')%             SmoothY=vecMovAverage(int16(Y),int16(w));%         else%             SmoothY=vecMovAverage(int32(Y),int32(w));%         end        SmoothY = filter(1/w*ones(1,w),1,Y);        % Taper the ends of the signal if ends=1.        if(ends==1)            startpoint=(smoothwidth + 1)/2;            SmoothY(1)=(Y(1)+Y(2))./2;            for k=2:startpoint                SmoothY(k)=mean(Y(1:(2*k-1)));                SmoothY(L-k+1)=mean(Y(L-2*k+2:L));            end            SmoothY(L)=(Y(L)+Y(L-1))./2;        end    end    function data = vecMovAverage(data,wnd)        %thanks to Christian Kothe        %https://de.mathworks.com/matlabcentral/fileexchange/34567-fast-moving-average        % pre-pend initial state & get dimensions        Y2 = [zeros(wnd,size(data,2),'like',data); data];        M = zeros(1,1,'like',wnd);        M(1) = size(Y2,1);        % get alternating index vector (for additions & subtractions)        I = [1:M-wnd; 1+wnd:M];        % get sign vector (also alternating, and includes the scaling)        S = [-ones(1,M-wnd,'like',data); ones(1,M-wnd,'like',data)];        % run moving average        Y2 = cumsum(bsxfun(@times,Y2(I(:),:),S(:)),1);        % read out result        data = single(Y2(2:2:end,:)).*(1/single(wnd));    endend